#include "oropezaanalysis.h"
#include <iostream>

OropezaAnalysis::OropezaAnalysis(double specGravWater, double specGravStone, double friction, double securityFactor)
{
    /*
     * A simple method for stability analysis as proposed by Oropeza-Mota & Lopez-Martinez (2009)
     *
     * Stability analysis for small gabion dams for soil conservation
     *
     * This assumes the following:
     *  - Dam is a single body.
     *  - Hydrostatic force is generated by the water and sediments retained by the dam's body. This is calculated using a triangle
     *    formed from the water level at the top of the weir to the bottom of the channel.
     *  - All the operations are performed over an unitary section of the dam which exclude the weir layers.
     *  - There is not pressure pushing up below the dam base
     */

    _sgWater = specGravWater;       // Specific gravity of water with sediment
    _sgStone = specGravStone;       // Specific gravity of stone
    _friction = friction;           // Friction factor for stone
    _safetyFactor = securityFactor; // Security factor for analysis

    checkParameterValues();
}

double OropezaAnalysis::friction() const
{
    return _friction;
}

void OropezaAnalysis::setFriction(double friction)
{
    _friction = friction;
}

double OropezaAnalysis::damBase() const
{
    return _damBase;
}

void OropezaAnalysis::setDamBase(double damBase)
{
    _damBase = damBase;
}

double OropezaAnalysis::damCrest() const
{
    return _damCrest;
}

void OropezaAnalysis::setDamCrest(double damCrest)
{
    _damCrest = damCrest;
}

double OropezaAnalysis::effectiveHeight() const
{
    return _effectiveHeight;
}

void OropezaAnalysis::setEffectiveHeight(double effectiveHeight)
{
    _effectiveHeight = effectiveHeight;
}

double OropezaAnalysis::damWeight() const
{
    return _damWeight;
}

void OropezaAnalysis::setDamWeight(double damWeight)
{
    _damWeight = damWeight;
}

double OropezaAnalysis::damLever() const
{
    return _damLever;
}

void OropezaAnalysis::setDamLever(double damLever)
{
    _damLever = damLever;
}

double OropezaAnalysis::frontLever() const
{
    return _frontLever;
}

void OropezaAnalysis::setFrontLever(double frontLever)
{
    _frontLever = frontLever;
}

bool OropezaAnalysis::slidingCondition() const
{
    return _slidingCondition;
}

void OropezaAnalysis::setSlidingCondition(bool slidingCondition)
{
    _slidingCondition = slidingCondition;
}

bool OropezaAnalysis::overturnCondition() const
{
    return _overturnCondition;
}

void OropezaAnalysis::setOverturnCondition(bool overturnCondition)
{
    _overturnCondition = overturnCondition;
}

bool OropezaAnalysis::centralCondition() const
{
    return _centralCondition;
}

void OropezaAnalysis::setCentralCondition(bool centralCondition)
{
    _centralCondition = centralCondition;
}

std::vector<Layer> OropezaAnalysis::dimensions() const
{
    return _dimensions;
}

void OropezaAnalysis::setDimensions(const std::vector<Layer> &dimensions)
{
    _dimensions = dimensions;
}

double OropezaAnalysis::damSectionVolume() const
{
    return _damSectionVolume;
}

void OropezaAnalysis::setDamSectionVolume(double damSectionVolume)
{
    _damSectionVolume = damSectionVolume;
}

double OropezaAnalysis::nappeWeight() const
{
    return _nappeWeight;
}

void OropezaAnalysis::setNappeWeight(double nappeWeight)
{
    _nappeWeight = nappeWeight;
}

double OropezaAnalysis::nappeLever() const
{
    return _nappeLever;
}

void OropezaAnalysis::setNappeLever(double nappeLever)
{
    _nappeLever = nappeLever;
}

double OropezaAnalysis::totalSliding() const
{
    return _totalSliding;
}

void OropezaAnalysis::setTotalSliding(double totalSliding)
{
    _totalSliding = totalSliding;
}

double OropezaAnalysis::totalOverturning() const
{
    return _totalOverturning;
}

void OropezaAnalysis::setTotalOverturning(double totalOverturning)
{
    _totalOverturning = totalOverturning;
}

double OropezaAnalysis::resultingForces() const
{
    return _resultingForces;
}

void OropezaAnalysis::setResultingForces(double resultingForces)
{
    _resultingForces = resultingForces;
}

double OropezaAnalysis::middleThird() const
{
    return _middleThird;
}

void OropezaAnalysis::setMiddleThird(double middleThird)
{
    _middleThird = middleThird;
}

double OropezaAnalysis::totalDisplacement() const
{
    return _totalDisplacement;
}

void OropezaAnalysis::setTotalDisplacement(double totalDisplacement)
{
    _totalDisplacement = totalDisplacement;
}

double OropezaAnalysis::thirdForces() const
{
    return _thirdForces;
}

void OropezaAnalysis::setThirdForces(double thirdForces)
{
    _thirdForces = thirdForces;
}

bool OropezaAnalysis::thirdCondition() const
{
    return _thirdCondition;
}

void OropezaAnalysis::setThirdCondition(bool thirdCondition)
{
    _thirdCondition = thirdCondition;
}

GabionDam *OropezaAnalysis::dam() const
{
    return _dam;
}

void OropezaAnalysis::setDam(GabionDam *dam)
{
    _dam = dam;
}

double OropezaAnalysis::safetyFactor() const
{
    return _safetyFactor;
}

void OropezaAnalysis::setSafetyFactor(double safetyFactor)
{
    _safetyFactor = safetyFactor;
}

double OropezaAnalysis::sgStone() const
{
    return _sgStone;
}

void OropezaAnalysis::setSgStone(double sgStone)
{
    _sgStone = sgStone;
}

double OropezaAnalysis::sgWater() const
{
    return _sgWater;
}

void OropezaAnalysis::setSgWater(double sgWater)
{
    _sgWater = sgWater;
}

void OropezaAnalysis::checkParameterValues()
{
    // Some parameters should not have values less or equal than zero, set to default value
    _sgWater = (_sgWater <= 0) ? 1.2 : _sgWater;
    _sgStone = (_sgStone <= 0) ? 2.4 : _sgStone;
    _friction = (_friction <= 0) ? 0.75 : _friction;
    _safetyFactor = (_safetyFactor <= 0) ? 1.0 : _safetyFactor;
}

double OropezaAnalysis::hydrostatic() const
{
    return _hydrostatic;
}

void OropezaAnalysis::setHydrostatic(double hydrostatic)
{
    _hydrostatic = hydrostatic;
}

double OropezaAnalysis::hydrostaticLever() const
{
    return _hydrostaticLever;
}

void OropezaAnalysis::setHydrostaticLever(double hydrostaticLever)
{
    _hydrostaticLever = hydrostaticLever;
}

bool OropezaAnalysis::performStabilityAnalysis()
{
    checkParameterValues();

    // Get the necessary data for the analysis
    _dimensions = _dam->getLayers();  // Get the dam dimensions as Layer objects
    _damBase = _dimensions.at(0).length();

    // TODO: define which is the crest of the dam, the top layer or the bottom spillway layer??
    //_damCrest = _dimensions.at(_dam->getSpillwayBottomLayer()-1).length();  // Bottom spillway layer
    _damCrest = _dimensions.at(_dimensions.size()-1).length();  // Top layer

    // Calculate the volume of the unitary section of the dam
    unitarySectionVolume();

    // Effective height is known by now
    _wetArea = _effectiveHeight;

    // Get the values of the forces and their levers
    calculateNappeWeight();       // q
    calculateNappeLever();        // Xq

    calculateDamSectionWeight();  // P
    calculateDamSectionLever();   // Zp

    calculateHydrostatic();       // E
    calculateHydrostaticLever();  // XE

    // Check the stability conditions: a) sliding, b) overturning and c) middle third
    checkSligindCondition();
    checkOverturnCondition();
    checkCentralCondition();

    // Verify the middle third condition
    if (!verifyMiddleThird())
        return false;

    // Create a final result
    if (!_slidingCondition || !_overturnCondition || !_centralCondition)
        return false;

    return true;
}

double OropezaAnalysis::wetArea() const
{
    return _wetArea;
}

void OropezaAnalysis::setWetArea(double wetArea)
{
    _wetArea = wetArea;
}

void OropezaAnalysis::unitarySectionVolume()
{
    _damSectionVolume = 0;
    _volumeSum = 0;
    _effectiveHeight = 0;

    for (int i=0; i < int(_dimensions.size() - _dam->getWeirLayers()); i++) {

        // Get the volume of the current layer and add it to the dam's unitary section volume (V)
        double layerVolume = _dimensions.at(i).length() * _dimensions.at(i).height();  // Width = 1
        _damSectionVolume = _damSectionVolume + layerVolume;

        // Volume of current layer times it's gravity center position
        _volumeSum = _volumeSum + (layerVolume * (_dimensions.at(i).length() / 2));

        // Increase the effective height of the dam (H), discard base layer.
        if (i != 0)
            _effectiveHeight = _effectiveHeight + _dimensions.at(i).height();
    }
}

void OropezaAnalysis::calculateNappeWeight()
{
    /* Calculates the weight of the nappe using:
     *
     * q = a * h' * b * w
     *
     * where:
     *
     * q  = weight of the nappe
     * a  = width of the section = 1
     * h' = water height over the weir crest
     * b  = length of the weir wall (crest)
     * w  = specific gravity of water with sediment
     *
     */

    _nappeWeight = _dam->getWeirWaterHeight() * _damCrest * _sgWater;
}

void OropezaAnalysis::calculateNappeLever()
{
    /* Calculates the lever of the nappe using:
     *
     * Xq = b / 2
     *
     * where:
     *
     * Xq = lever of the nappe
     * b  = length of the weir wall (crest)
     *
     */

    _nappeLever = _damCrest / 2;
}

void OropezaAnalysis::calculateDamSectionWeight()
{
    /* Calculates the weight of the unitary section of the dam:
     *
     * P = V * ap_sg
     *
     * where:
     *
     * P     = weight of the unitary section of the dam
     * ap_sg = apparent specific gravity = delta - w
     * delta = specific gravity of stone
     * w  = specific gravity of water with sediment
     *
     */

    _damWeight = _damSectionVolume * (_sgStone - _sgWater);
}

void OropezaAnalysis::calculateDamSectionLever()
{
    /* Calculates the lever of the weight of dam's unitary section:
     *
     * Zp = SumVol / V;
     *
     * where:
     *
     * Zp = lever of weight of unitary section
     * V  = volume of the dam's uniraty section
     *
     * Please refer to documentation to see why this is computed this way!
     *
     */

    _damLever = _volumeSum / _damSectionVolume;
}

void OropezaAnalysis::calculateHydrostatic()
{
    /* Calculates the hydrostatic pressure of the water with sediments:
     *
     * E = Sm * h * w;
     *
     * where:
     *
     * E  = hydrostatic pressure
     * Sm = wet area = H * a
     * h  = centroid of Sm = H / 2
     * w  = specific gravity of water with sediment
     * a  = 1
     * H  = effective height
     *
     */

    //_hydrostatic = 1.5 * _effectiveHeight * _w;
    _hydrostatic = _wetArea * (_effectiveHeight/2.0) * _sgWater;
}

void OropezaAnalysis::calculateHydrostaticLever()
{
    /* Calculates the lever of the hydrostatic pressure:
     *
     * XE = H / 3
     *
     * where:
     *
     * XE = lever of the hydrostatic pressure
     * H  = effective height
     *
     */

    _hydrostaticLever = _effectiveHeight / 3;
}

bool OropezaAnalysis::checkSligindCondition()
{
    /* Checks the sliding condition
     *
     * The weight of the nappe and dam together should be greather than hydrostaic pressure
     */

    _totalSliding = ((_nappeWeight + _damWeight) * _friction) / _hydrostatic;

    // This value should be greather than the security factor
    _slidingCondition = _totalSliding > _safetyFactor;

    return _slidingCondition;
}

bool OropezaAnalysis::checkOverturnCondition()
{
    /* Checks the overturning condition
     *
     * The dam weight times its lever should be greather than hydrostatic pressure times its lever
     */

    _frontLever = _damBase - _damLever;
    _totalOverturning = (_damWeight * _frontLever) / (_hydrostatic * _hydrostaticLever);

    // This value should be greather than the security factor
    _overturnCondition = _totalOverturning > _safetyFactor;

    return _overturnCondition;
}

bool OropezaAnalysis::checkCentralCondition()
{
    /* Checks the central condition
     *
     * The resulting std::vector of all the forces over the dam should be at 2/3 of the base length
     *
     */

    _resultingForces = _nappeWeight * _nappeLever + _damWeight * _damLever + _hydrostatic * _hydrostaticLever;
    _thirdForces = (2./3.) * (_nappeWeight + _damWeight) * _damBase;
    _centralCondition = _resultingForces < _thirdForces;

    return _centralCondition;
}

bool OropezaAnalysis::verifyMiddleThird()
{
    /*
     * The resultant force should be located in the middle third of the dam base.
     * NOTE: Check nomenclature for this!
     *
     * Using similar triangles for the resultant force (R) with P and E, let
     * alpha be the angle of R:
     *
     * tan(alpha) =  E / P
     *
     * Also:
     *
     * tan(alpha) = Z' / XE
     *
     * where: Z' is the horizontal displacement of P when E is applied
     * XE is the lever of the hydrostatic pressure
     *
     * Then:
     * Z' = tan(alpha) * XE
     *
     */

    double tan_alpha = _hydrostatic / _damWeight;

    // Horizontal displacement
    double hor_displacement = tan_alpha * _hydrostaticLever;

    // Total displacement
    _totalDisplacement = _damLever + hor_displacement;
    _middleThird = 2 * (_damBase / 3);
    _thirdCondition = _middleThird > _totalDisplacement;

    return _thirdCondition;
}

